\chapter{Grundlagen}\label{sec:grundlagen}

\section{Steuergeräte}\label{subsec:steuergeraete}

Im Jahr 1967 führte VW erstmals die elektronische Motorsteuerung D-Jetronic von Bosch in einem Serienfahrzeug ein. Dieses System ermöglichte es erstmals, das Verhältnis des Kraftstoff-Luft-Gemischs elektronisch entsprechend dem aktuellen Betriebszustand des Motors anzupassen und so den Kraftstoffverbrauch zu reduzieren \cite[S. 13]{schaeffer2013}. Das damals noch als futuristisch gesehene Konzept ist heute aus der Motorensteuerung nicht mehr wegzudenken und kennzeichnet den Beginn des Siegeszugs elektronischer Steuergeräte.

Laut James Priyatham enthält ein modernes Luxusfahrzeug über 150 Steuergeräte \cite[]{numberEcus}. Diese umfassen die bereits erwähnten Motorsteuergeräte, aber auch Fahrsicherheitssysteme wie das ABS oder den Airbag. Verstärkt finden sich immer mehr Steuergeräte, die einzig allein dem Fahrkomfort wie Lenkassistenten oder einem Infotainment System dienen \cite[S. 1]{Wolf2018}. 

% Mehr Historie über entwicklung, 
% Von CAN bis Ethernet

\section{AUTOSAR}\label{subsec:autosarclassic}

Um die wachsende Komplexität von Steuergeräten in modernen Fahrzeugen zu reduzieren, gründeten sieben deutsche Kfz-Hersteller und Zulieferer 2003 die AUTOSAR-Entwicklungspartnerschaft, in der der De-Facto Industriestandard AUTOSAR Classic erarbeitet wurde. Dieser immer wieder aktualisierte Standard definiert in \cite{AUTOSAR2020} die folgenden Projektziele:
\begin{enumerate}
\item Übertragbarkeit von Software
\item Skalierbarkeit für unterschiedliche Fahrzeuge und Plattformvarianten
\item Unterstützung einer Vielzahl von Funktionsdomänen
\item Definition einer offenen Architektur
\item Unterstützung der Entwicklung von zuverlässigen Systemen
\item Nachhaltige Nutzung natürlicher Ressourcen
\item Standardisierung von Basissoftwarefunktionalität von Steuergeräten
\item Unterstützung von relevanten internationalen Automobilstandards und etablierten technischen Lösungen
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{images/autosarclassic.pdf}
	\caption{AUTOSAR Classic Architektur \\ Quelle: Eigene Darstellung nach \cite{autosarlayers}}
	\label{fig:autosarlayers}
\end{figure}

Um dies zu erreichen, definiert AUTOSAR neben anderen Aspekten wie der Entwicklungsmethodik eine Referenzarchitektur für Steuergeräte-Software, die die eigentliche Hardware eines Steuergeräts über die folgenden drei Schichten für Anwendungen abstrahiert:

\begin{itemize}
\item \textbf{Application Layer} Software, die vom Hersteller für den Verwendungszweck des Steuergeräts entwickelt wird
\item \textbf{Runtime Enviroment} Definiert die Kommunikation zwischen der Application Layer und der Basissoftware
\item \textbf{Basic Software} Softwarekomponente, die grundlegende Standarddienste des Steuergeräts bereitstellen
\end{itemize}

Die Basic Software wird wiederum in die folgenden drei Schichten eingeteilt:
\begin{itemize}
\item \textbf{Microcontroller Abstraction Layer} Treiber für die spezifische Hardware
\item \textbf{ECU Abstraction Layer} Hardwareunabhängige Schnittstelle für Hardwarearten
\item \textbf{Services Layer} Schnittstellen für konkrete Services wie kryptografische Funktionen
\item \textbf{Complex Drivers} Services, die nicht auf den vorherigen Schichten aufbauen, da sie z. B. zeitkritisch sind
\end{itemize}

\cite[]{autosarlayers}

Ein potenzielles Sicherheitsrisiko sehen \citet{attackingAutosar} in der Abstraktionsschicht von Mikrocontrollern. Im Gegensatz zu anderer Basissoftware werden diese Komponenten oft von den Mikrocontroller-Herstellern selbst implementiert. Wenn diese den AUTOSAR-Standard nicht ordnungsgemäß implementierten, kann es sein, dass bei der Integration mit der sonstigen Software des Steuergeräts Sicherheitslücken in das System eingeführt werden.

Zudem stellen die für den AUTOSAR-Standard implementierten Kommunikationsstacks ein Sicherheitsrisiko dar, da sie aufgrund ihres Nischendaseins nicht so gut getestet wurden wie etablierte Kommunikationsstacks wie der des Linux-Kernels. 

\subsection{AUTOSAR Kommunikationsstacks}\label{subsec:kommunikationsstacks}

Der AUTOSAR Standard benennt die folgenden Netzwerkprotokolle als Teil des Kommunikationsstacks:

\subsubsection{CAN}\label{subsec:can}

Das Controller Area Network (CAN) ist ein von der Robert Bosch GmbH erfundener Kommunikationsbus, der 1986 auf dem Kongress der Society of Automotive Engineers (SAE) in Detroit als Alternative zur damals üblichen Punkt-zu-Punkt-Verkabelung in Fahrzeugen vorgestellt wurde. Nachrichten in CAN werden auf dem Bus an alle Steuergeräte übertragen, welche anhand des \path{Message Identifiers} entscheiden, ob die gesendete Nachricht von ihnen weiterverarbeitet wird oder nicht.

CAN verwendet ein CSMA/CA-Verfahren (Carrier-sense multiple access with collision avoidance) für den Buszugriff. Dabei beobachtet jedes Steuergerät den Bus für einen bestimmten Zeitraum ohne Aktivität, bevor es versucht, eine Nachricht zu senden. Jeder Teilnehmer des Busses hat die gleiche Chance, eine Nachricht zu senden, was potenziell zu Nachrichtenkollisionen führen kann. Beim Senden jedes Bits des \path{Message Identifiers} am Anfang einer Nachricht überprüft der Absender, ob die gesendeten Daten mit den empfangenen Daten übereinstimmen. Stimmen die Bits nicht überein, weiß der Absender, dass zur gleichen Zeit eine Nachricht mit höherer Priorität auf dem Bus übertragen wurde und bricht den Sendevorgang ab. Ein erneuter Sendeversuch wird erst wieder unternommen, wenn eine bestimmte Zeitspanne ohne Aktivität verstrichen ist \cite[S. 57]{bussyteme}.

\subsubsection{LIN}\label{subsec:LIN}

Bei LIN (Local Interconnect Network) handelt es sich um ein Ende der 1990er-Jahre erschienenes Bussystem, das kostengünstiger als CAN ist, allerdings einen geringeren Datendurchsatz aufweist. Anders als CAN, handelt es sich bei LIN um einen Master/Slave Bus. Sämtliche Nachrichten gehen von einem einzigen Master aus, dem die Slaves antworten, wodurch Nachrichtenkollisionen verhindert werden \cite[S. 79]{bussyteme}.

\subsubsection{FlexRay}\label{subsec:Flex}

Im Jahr 1999 gründeten BMW, Daimler, Motorola und Philips das FlexRay-Konsortium, um ein fehlertolerantes Kommunikationssystem mit Übertragungsraten von bis zu 10 Mbit/s zu entwickeln.

Neben den bekannten Bustopologien unterstützt FlexRay auch Sterntopologien, bei denen ein zentraler Knoten die Weiterleitung der Nachrichten übernimmt. 

Das Protokoll arbeitet zyklisch und teilt die Datenübertragung in zwei Teile, einen statischen und einen dynamischen Teil. Im statischen Teil wird jedem Knoten des Busses eine kleine Zeitspanne eingeräumt, in der er ungestört Nachrichten senden kann. Im dynamischen Teil kann wie bei CAN jeder Teilnehmer nach Belieben Nachrichten senden. Ferner enthält der Zyklus ein kleines Zeitfenster, welches die Synchronisation der Teilnehmer erlaubt \cite[S. 96]{bussyteme}.

\subsubsection{Automotive Ethernet}\label{subsec:ethernet}

Bei Automotive Ethernet handelt es sich um eine Sonderform von Ethernet, die auf die Bedürfnisse der Automobilindustrie zugeschnitten wurde. Ethernet wurde in den 70er-Jahren vom Xerox Palo Alto Research Center  für die Vernetzung von Computer Workstations entwickelt, 1980 in der ersten Version des Standards IEEE 802 standardisiert und über die Jahre fortlaufend weiterentwickelt \cite[S. xxxii]{automotiveethernet}.

Obwohl Ethernet in den Anfangsjahren eine Bustopologie unterstütze, handelt es sich bei Automotive Ethernet hauptsächlich um eine Sterntopologie.

Für die Verwendung in der Automobilindustrie wurde Ethernet so weiter entwickelt, dass es den besonderen Anforderungen der Branche gerecht wurde. Zu den besonderen Anforderungen zählen unter anderem die Einhaltung der Grenzwerte für abgestrahlte elektromagnetische Störgrößen \cite[S. 109]{automotiveethernet}, wie aber auch eine große Resilienz für Temperaturen, welche im Fahrzeuginneren von -40 \textdegree{}C bis +105 \textdegree{}C reichen können \cite[S. 320]{automotiveethernet}. IEEE Standards, welche diese besonderen Anforderungen erfüllen, sind 100BASE-T1, 1000BASE-T1 so wie 100BASE-TX \cite[S. 217]{automotiveethernet}

Im Open Systems Interconection (OSI)- Modell lässt sich Automotive Ethernet in der untersten Schicht als Bitübertragungsschicht einordnen. Neben den verwendeten Ethernet Standard meint man aber mit Automotive Ethernet auch meist die folgenden Protokolle, welche über der zweiten Schicht einzuordnen sind.

\begin{table}[H]
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|llll}
\textbf{Netzwerkprotokoll} & \textbf{CAN (ISO 11898)} & \textbf{LIN} & \textbf{FlexRay} & \begin{tabular}[c]{@{}l@{}}\textbf{Ethernet }\\\textbf{(100BASE-T1)}\end{tabular} \\ 
\hline
\textbf{Topologie} & BUS & BUS & BUS, Stern & Stern \\
\textbf{Nutzdatenraten} &  1 mbit/s &  20 kbit/s &  10 mbit/s &  100 mbit/s \\
\textbf{Kabel Typ} & zweiadrig & einadrig & \begin{tabular}[c]{@{}l@{}}Glasfaser \\oder zweiadrig\end{tabular} & zweiadrig \\
\textbf{Anwendung} & \begin{tabular}[c]{@{}l@{}}Motorsteuerung, \\Scheinwerfer, \\Klimaanlage\end{tabular} & \begin{tabular}[c]{@{}l@{}}Fensterheber, \\Temperatursensoren, \\Klimaanlagen-\\ventilatoren\end{tabular} & \begin{tabular}[c]{@{}l@{}}Lenkwinkelsensor, \\Getriebesteuerung, \\Notbremsassistent\end{tabular} & \begin{tabular}[c]{@{}l@{}}Infotainment, \\Kameras, \\Radare\end{tabular}
\end{tabular}
}
  \caption{Überblick Netzwerkprotokolle}\label{tab:netzwerkprotokole}
\end{table}

\subsection{Automotive Ethernet Protokolle}\label{subsec:ethernetprotokolle}

Während bei den Kommunikationsstacks, die primär für den Automobilsektor entwickelt wurden, häufig die Application Layer direkt auf dem Data Link aufbaut, enthält Automotive Ethernet eine breite Auswahl an Protokollen, die sich auf den unterschiedlichsten Layern des OSI Modells ansiedeln.

\subsubsection{SOME/IP}\label{subsec:someip}

Bei SOME/IP (Scalable service-Oriented Middleware over IP) handelt es sich um eine Middleware, welche eine serviceorientierte Übertragung von Informationen ermöglicht. Anders als bei der signalbasierten Kommunikation, werden hier lediglich Informationen versendet, wenn ein Empfänger mitgeteilt hat, dass er diese benötigt.

Um dies zu ermöglichen, stellt SOME/IP die folgenden Servicekonzepte zur Verfügung:
\begin{itemize}
\item \textbf{Request/Response} Der Client sendet eine Nachricht an den Server und erhält eine Antwort vom Server
\item \textbf{Fire and Forget} Der Client sendet  eine Nachricht an den Server, erwartet jedoch keine Antwort vom Server
\item \textbf{Events} Der Client abonniert auf dem Server eine Information, die der Server bei bestimmten Ereignissen oder regelmäßig an den Client sendet
\item \textbf{Fields} Der Client kann ein Feld lesen oder je nach Konfiguration auch schreiben und erhält zyklisch oder bei einer Veränderung den aktuellen Wert des Felds
\end{itemize} 
\cite[S. 289]{automotiveethernet}

Für die Erkennung, welche Services in einem Netzwerk angeboten werden, enthält SOME/IP zusätzlich einen Service Discorvery Mechanismus. Dies ist z. B. beim Start des Fahrzeugs sinnvoll, da Steuergeräte unterschiedlich lange brauchen, um zu starten, und so das Fahrzeug bereits frühzeitig mit einem limitierten Funktionsumfang parat steht. Es kann auch sein, dass ein bestimmtest Steuergerät wegen einer zu niedrigen Versorgungsspannung, eines Defekts oder einfach, weil es in der Fahrzugkonfiguration des Kunden nicht enthalten ist, nicht kontaktierbar ist und deshalb andere Steuergeräte darauf entsprechend reagieren müssen \cite[S. 291]{automotiveethernet}.

%\subsubsection{Protocol Data Units}\label{subsec:pdu}
%\cite{neuekommunikation}

\subsubsection{DoIP}\label{subsec:doip}

Bei DoIP handelt es sich um ein Diagnoseprotokoll, das direkt mit den Steuergeräten im Ethernet Netzwerk des Fahrzeugs über den Diagnoseport kommuniziert.
Dafür benötigt das Diagnosegerät zunächst eine IP, die es entweder über einen DHCP Server im Netz des Fahrzeuges erhält oder im Fall, dass kein DHCP Server antwortet, zufällig generiert. 
Im nächsten Schritt sendet das Diagnosegerät einen Vehicle Announcement Broadcast, woraufhin sich alle Steuergeräte beim Diagnosegerät melden. An das passende Steuergerät versendet das Diagnosegerät eine „routing activation request“, woraufhin die Diagnosekommunikation startet\cite[]{doip}.

\section{ISO 15118 Protokole}\label{subsec:fahrzeugkommunikation}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/OSI-15118.pdf}
	\caption{ISO 15118 im OSI-Modell}
	\label{fig:iso15118}
\end{figure}

Nicht nur über Automotive Ethernet findet in einem Fahrzeug IP basierte Kommunikation statt, sondern auch bei der Kommunikation zwischen einer Ladesäule und einem Fahrzeug. Wie diese Kommunikation auszusehen hat, ist in ISO 15118 beschrieben.  

\subsubsection{HomePlug GreenPhy}\label{subsec:homeplug}

Im Gegensatz zu Automotive Ethernet existiert zwischen Fahrzeug und Ladestation mit dem Control Pilot Pin eines IEC 62196-2 Ladesteckers nur eine Datenleitung für Steuersignale. Auf diesem Pin liegt ein Signal mit einer Frequenz von 1 kHz und einer Spannung von +/-12 V an, die je nach Akkuzustand über einen größeren oder kleineren Widerstand auf der Fahrzeugseite auf den Schutzleiter abgeleitet wird \cite[]{ladestecker}.

Weiterer Datenverkehr wird durch ein Nutzsignal mittels orthogonalem Frequenzmultiplexverfahren auf die Frequenz des Control Pilot Pins moduliert. Dieses Verfahren ist vielen durch die Verwendung in Powerline Netzwerkadaptern, häufig nur als DLAN-Steckern bezeichnet, bekannt, welche häufig auf den Standard HomePlug AV setzen. Für die Verwendung zwischen einem Fahrzeug und einer Ladesäule wird laut ISO 15118-3 „Physical and data link layer requirements“ der Standard HomePlug GreenPhy verwendet, welcher zu HomePlug AV kompatibel ist, allerdings einen geringeren Funktionsumfang bietet \cite[S. 302]{homepluggreenphy}.


Aufgrund von Übersprecheffekten anderer Ladesäulen über das gemeinsame Stromnetz, kann es vorkommen, dass dem Elektrofahrzeug mehrere Ladestationen auf eine Kommunikationsaufforderung antworten. Das SLAC-Protokol hat die Aufgabe, die Ladestation zu finden, mit der das Fahrzeug physikalisch verbunden ist. Dafür sendet das Fahrzeug zunächst eine \path{CM_SLAC_PARM.REQ} mit entsprechenden Parametern. Die Ladestationen antworten darauf mit einer \path{CM_SLAC_PARM.CNF} Nachricht, die Parameter wie die Anzahl der M-Sounds angibt. Daraufhin signalisiert das Fahrzeug mit \path{CM_START_ATTEN_CHAR.IND} Nachrichten, dass die Ladestationen mit der Messung der Signalabschwächung beginnen sollen. Die tatsächliche Messung der Signalabschwächung geschieht anhand der \path{CM_MNB_SOUND.IND} des Fahrzeugs, welches entsprechend M-Sounds oft versendet wird. Auf jede dieser Nachrichten antwortet die Ladestation mit einer \path{CM_ATTEN_PROFILE.IND} Nachricht, welche die gemessene Signalabschwächung enthält. 

Anhand der gemessenen Werte bestimmt dann das Fahrzeug die richtige Ladesäule, was es über eine \path{CM_SLAC_MATCH.REQ} Nachricht der Ladesäule signalisiert, welche darauf mit einer \path{CM_SLAC_MATCH.CNF} Nachricht antwortet. 

Die Antwort der Ladesäule enthält die Network-ID und den Network-Membership-Key, welchen das Fahrzeug nutzt, um dem logischen Netzwerk der Ladesäule beizutreten und die Kommunikation auf einer höheren Schicht fortzuführen \cite[S. 310]{homepluggreenphy}.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{images/SLACC.png}
	\caption{Antwort der Ladesäule mit der Stärke des Signals auf eine Sound-Anfrage des Fahrzeugs}
	\label{fig:slacc}
\end{figure}

\subsubsection{Wi-Fi}\label{subsec:wifi}

Neben kabelgebundener Datenübertragung erlaubt ISO 15118-20 auch induktives Laden. Dabei findet die Datenübertragung anstelle von HomePlug über IEEE802.11n Wi-Fi 4 statt. \cite{ladepause} kritisiert an ISO 15118-20, dass zwar die Kommunikation mit TLS-Version 1.2 oder höher abzusichern ist, allerdings keine WPA2 Verschlüsselung gefordert wird. Ein alternativer Ansatz, der die Datenübertragung per IEEE802.11p vornimmt und die Datensicherheit mit ETSI TS 103 097 herstellt, wird zurzeit in Fachkreisen diskutiert.

\subsubsection{IPv6 Neighbor Discovery Protocol}\label{subsec:ipv6ndp}

Um die Ladesäule und das Fahrzeug in ihrem Link-Local IPv6 Netzwerk aufzulösen, verwenden sie das Neighbor Discovery Protocol. Dazu wird ein Neighbor Discovery Cache auf den Geräten angelegt, der IPv6 Adresse mit Ethernet Adressen (MAC Adressen) verknüpft (vergleichbar mit dem ARP-Cache bei IPv4). Dies geschieht über die folgenden ICMPv6 Nachrichten:

\begin{itemize}
\item \path{Router Solicitation}: Werden von Hosts verschickt, um einen Router aufzufordern, ein \path{Router Advertisement} zu senden
\item \path{Router Advertisement}: Wird regelmäßig vom Router oder auf Anfrage eines Hosts versendet und enthält verbindungsspezifische Informationen wie Routen
\item \path{Neighbor Solicitation}: Werden von Hosts verschickt, um die MAC-Adresse eines anderen Hosts anzufordern, aber auch für Funktionen wie die Erkennung doppelter Adressen (Siehe Kapitel \ref{subsec:slaac})
\item \path{Neighbor Advertisement}: Werden als Antwort auf \path{Neighbor Solicitation}-Nachrichten gesendet. Wenn ein Host seine MAC-Adresse ändert, kann er unaufgefordert diese Nachricht senden, um die neue Adresse bekannt zu geben.
\end{itemize}

\cite[S. 499]{ipnetze}

\subsubsection{IPv6 Stateless Address Autoconfiguration}\label{subsec:slaac}
Anders als in IPv4 benötigt IPv6 nicht zwingend einen DHCP Server, um eine IP-Adresse zu erhalten. 

Dazu verwendet die Ladestation oder das Fahrzeug das Link-Local Präfix fe80:: für die ersten 64 Bits der Adresse, invertiert die ersten 24 Bits der MAC-Adresse, fügt die 16 Bits \path{0xfffe} hinzu und vervollständigt die Adresse mit den letzten 24 Bits der MAC-Adresse. Daraufhin überprüft das Gerät mit einer \path{Neighbor Solicitation} Nachricht, ob ein anderes Gerät bereits diese Adresse verwendet.
Im eigentlich ausgeschlossenen Fall, dass ein Gerät mit einem \path{Neighbor Advertisement} antwortet (MAC-Adressen dürfen nicht doppelt vergeben werden), kann der Netzwerkteilnehmer versuchen, erneut eine Adresse zu generieren und prüft diese erneut auf eine Kollision mit einem \path{Neighbor Advertisement} \cite[S. 505]{ipnetze}.


\subsubsection{SECC Discovery Protocol}\label{subsec:secc}

Nachdem der DataLink etabliert wurde, sendet das Fahrzeug einen \path{SECCDiscoveryReq} als IPv6 Multicast an alle Netzknoten. In dieser Nachricht fragt das Fahrzeug nach der IP-Adresse und dem Port der Ladesäule, mit der es sich über TCP verbinden soll. Darin legt es fest, ob die Verbindung über TLS verschlüsselt werden soll oder nicht. Zusätzlich enthält es noch ein Byte, mit dem das Transportprotokoll festgelegt wird. Dieses ist jedoch laut \cite[]{masterIso15118} aktuell unbenutzt, da die Kommunikation im Standard nur über TCP stattfindet. 

Die Ladesäule antwortet darauf mit einer \path{SECCDiscoveryRes} Nachricht, welche die IP der Ladesäule, den Port für die TCP Verbindung und ob die Ladesäule TLS unterstützt enthält.

Bestimmte Funktionen wie Plug-and-Charge können nur verwendet werden, wenn die Verbindung TLS verschlüsselt ist. In der Version zwei des Standards ist TLS für die Kommunikation verpflichtend. 

\cite[S. 123]{masterIso15118}.

\subsubsection{Transport Layer Security}\label{subsec:tls}

Bei TLS handelt es sich um ein Ende-zu-Ende-Verschlüsselungsprotokol, das besonders empfindliche Daten wie die Zahlungsinformationen bei Plug-and-Charge einer Ladesäule absichern soll. Der Standard ist vorwiegend durch seine Verwendung im Internet bekannt, wird aber in der AUTOSAR Classic Plattform seit Release 4.4.0. unterstützt \cite[Kapitel 5.2]{automotiveprotocolssecurity}.

Das TLS-Protokoll war ursprünglich als SSL (Secure Socket Layer) bekannt und wurde von Netscape entwickelt. Die dritte Version von SSL ist heute als TLS 1.0 bekannt und wird in RFC 2246 beschrieben. Die aktuellste Version des Standards ist TLS 1.3, das im August 2018 als RFC 8446 veröffentlicht wurde \cite[S. 376]{ipnetze}.

Um TLS gemäß ISO 15118 Version 1 zu verwenden, müssen Ladesäule und Fahrzeug TLS 1.2 sowie mindestens die folgenden zwei TLS Chiffren unterstützen:
\begin{itemize}
\item \path{TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256}\footnote{\url{https://ciphersuite.info/cs/TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256/}}
\item \path{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256}\footnote{\url{https://ciphersuite.info/cs/TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256/}}
\end{itemize}

Laut der zweiten Version des ISO 15118 Standards, sollen TLS 1.3 und die folgenden zwei TLS Chiffren verwendet werden:
\begin{itemize}
\item \path{TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256}\footnote{\url{https://ciphersuite.info/cs/TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256/}}
\item \path{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256}\footnote{\url{https://ciphersuite.info/cs/TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256/}}
\end{itemize}

\cite[]{frauenhoferIsoTLS}

\begin{figure}[H]
	\centering
	\includesvg[width=\textwidth,inkscapelatex=false]{images/TLS_Ladesäule.svg}
	\caption{Sequenz der TLS Kommunikation \\ Quelle: Eigene Darstellung nach \cite{masterIso15118}}
	\label{fig:context}
\end{figure}

Die Plug-and-Charge-Erweiterung von ISO 15118 ermöglicht es Fahrzeugen, sich an einer Ladestation ohne weitere Authentifizierungsverfahren wie eine App oder RFID-Karte zu authentifizieren. Dazu benötigen die Ladesäule und das Fahrzeug ein digitales X.509v3-Zertifikat. Dieses sogenannte Leaf-Zertifikat wird von einem OEM mit einem Sub-CA Zertifikat bei der Herstellung des Fahrzeugs und der Ladesäule ausgestellt. Die Sub-CA Zertifikate der OEMs werden wiederum von einem Root Zertifikat, dem sogenannten V2G Root, ausgestellt. Wer welche Zertifikate ausstellen darf, ist im Handbuch „Zertifikats-Handhabung für Elektrofahrzeuge, Ladeinfrastruktur und Backend-Systeme im Rahmen der Nutzung von ISO 15118“ des Deutschen Verbands der Elektrotechnik, Elektronik und Informationstechnik geregelt \cite[S. 10]{pkiInfo}.

Das Fahrzeug kann mit dem Online Certificate Status Protocol überprüfen, ob ein Zertifikat einer Ladesäule widerrufen wurde. Eine Prüfung der Zertifikate des Fahrzeugs findet in diesem Schritt nicht statt \cite[S. 10]{pkiInfo}. 

Mit der OCSP Prüfung der Ladesäulen Zertifikaten läuft der TLS Verbindungsaufbau folgendermaßen ab:

\begin{enumerate}
\item Das Fahrzeug sendet im \path{ClientHello} Handshake seine Verbindungsparameter wie die unterstützen Chiffren an die Ladesäule. Durch die \path{status_request_v2} Extension fordert das Fahrzeug die Ladesäule auf, ihre Zertifikate durch einen OCSP Request zu authentifizieren. Zudem sendet das Fahrzeug mit der \path{trusted_ca_keys} Extension eine Lister aller V2G Root Zertifikaten, denen es vertraut.
\item Die Ladesäule verarbeitet das \path{ClientHello} 
\item Die Ladesäule sendet eine OCSP Anfrage mit seinen Zertifikaten an den OCSP Responder. 
\item In der OCSP Antwort wird mit einem Zeitstempel angegeben, ob die überprüften Zertifikate widerrufen wurden. Die Antwort wird zusätzlich digital signiert, um die Authentizität der Antwort zu beweisen.
\item Die Ladesäule antwortet mit dem \path{ServerHello} seine Verbindungsparameter wie die höchstmögliche unterstützte Chiffre. Mit der \path{status_request_v2} Extension signalisiert die Ladesäule OCSP Validierungen zu unterstützen.
\item Die Ladesäule sendet seine Zertifikatskette, bestehend aus Sub-CA und Leaf. Diese müssen von einem aus Schritt 1 unterstützten V2G Root Zertifikat abgeleitet sein.
\item Die OCSP Antwort aus Schritt 4 wird an das Fahrzeug übertragen
\item Entsprechenden der gewählten Chiffre werden Informationen für die Bildung eines gemeinsamen Schlüssels versandt
\item Die Ladesäule signalisiert, dass die „Hello“-Phase abgeschlossen ist
\item Das Fahrzeug validiert das Zertifikat der Ladesäule und die OCSP Antwort
\item Das Fahrzeug sendet nun wie die Ladesäule in Schritt 8 Informationen, um einen gemeinsamen Schlüssel zu bilden
\item Das Fahrzeug teilt mit, dass ab nun die Kommunikation verschlüsselt stattfindet
\item Das Fahrzeug teilt mit, das der Schlüsselaustausch und die Authentifizierung erfolgreich waren
\item Die Ladesäule teilt mit, dass ab nun die Kommunikation verschlüsselt stattfindet
\item Die Ladesäule teilt mit, das der Schlüsselaustausch und die Authentifizierung erfolgreich waren
\end{enumerate}

\subsubsection{Vehicle to Grid Transfer Protocol}\label{subsec:v2g}

Bei dem V2GTP Protokoll handelt es sich um einen Session Wrapper, der die Daten mit Headern versieht. Diese Header enthalten Informationen über die Version, die Länge und der Kodierungsmethode der Payload \cite[S. 27]{masterIso15118}.

\subsubsection{Vehicle to Grid Protocol}\label{subsec:v2g}

Die eigentlichen Daten werden im Efficient XML Interchange Format nach den in ISO 15118-2 definierten Schemata formatiert.
Bei dem Efficient XML Interchange Format handelt es sich um XML, das in Binär anstelle von Klartext gespeichert wird. Dies reduziert zum einen die Dateigröße, beschleunigt aber auch das Parsen \cite[]{exi}.

\section{Vector Informatik GmbH}\label{subsec:vectorunternehmen}

Die Vector Informatik GmbH ist einer der führenden Hersteller von Softwarewerkzeugen, Hardware und Softwarekomponenten für die Entwicklung elektronischer Systeme und deren Vernetzung über die in Kapitel \ref{subsec:kommunikationsstacks} genannten Busse. Dabei ist das Unternehmen insbesondere in der Automobilbranche präsent. Am 1. April 1988 gründeten Martin Litschel, Dr. Helmut Schelling und Eberhard Hinderer die „Vector Software GmbH“ in Ditzingen. Das erste Projekt des Unternehmens war damals eine Softwarelösung für NC-gesteuerte Bearbeitungszentren, die aufgrund komplexer Vektorberechnungen auch als Inspiration für den Firmennamen diente. Im Jahr 1995 zog das Unternehmen von Ditzingen nach Stuttgart-Weilimdorf. 1997 erfolgte die Gründung der ersten Auslandstochter, der Vector CANtech in Novi (USA). Heute ist das Unternehmen an 26 Standorten in 13 Ländern mit über 3.000 Mitarbeitern weltweit tätig und erzielte 2019 einen Umsatz von 770 Millionen Euro \cite[]{firmengeschichte}.

\section{CANoe}\label{subsec:canoe}

CANoe\footnote{\url{https://www.vector.com/canoe/}} ist ein Software-Entwicklungs- und Testwerkzeug der Vector Informatik GmbH, das vorwiegend von Automobilherstellern und -zulieferern für die Entwicklung, Simulation, dem Testen und der Inbetriebnahme von Kommunikationsnetzwerken und Steuergeräten eingesetzt wird. Steuergerätesoftware kann zu diesem Zweck entweder virtualisiert oder über entsprechende Schnittstellen auf reale Hardware in einer Testumgebung ausgeführt werden. In dieser Testumgebung kann die Testfunktionalität mit der ereignisorientierten Programmiersprache CAPL oder CSharp implementiert werden. Die Kommunikation in der Testumgebung kann mit umfangreichen Traces nachverfolgt und somit debuggt werden. CANoe unterstützt alle in Kapitel \ref{subsec:kommunikationsstacks} genannten Kommunikationsstacks. 

Für Simulationen unterscheidet CANoe zwischen den folgenden zwei Arbeitsmodi:
\begin{itemize}
\item \textbf{Simulierter Bus} Die Simulation findet in einem komplett simulierten Netzwerk statt. Es ist möglich, die Geschwindigkeit einer Simulation zu verändern.
\item \textbf{Realer Bus} Die Simulation findet auf einem verbundenem Netzwerkinterface statt. Dies ermöglicht das Hinzufügen realer Hardware.
\end{itemize}

\cite[]{simulatingcanoe}

\section{vTESTstudio}\label{subsec:vteststudio}

vTESTstudio\footnote{\url{https://www.vector.com/vteststudio/}} ist eine Testumgebung der Vector Informatik GmbH für eingebettete Systeme, die das Design, die Erstellung und die Ausführung von Tests erleichtert. Dazu können in der Entwurfs- und Implementierungsphase abstrakte Testfälle in CAPL, CSharp oder Python implementiert werden, die in Menüs für Testfälle entsprechend zusammengestellt und parametrisiert werden können. Für die Entwicklung von Elektroladesäulen bietet Vector mit dem CANoe Test Package EV\footnote{\url{https://www.vector.com/de/de/produkte/produkte-a-z/software/canoe-test-package-ev/}} vorgefertigte Testfälle an, die vom Kunden in vTESTstudio konkret parametrisiert werden können. 

Die Tests werden in der Testphase in für CANoe verständlichen Code kompiliert und in der Simulation ausgeführt. Aus den ausgeführten Tests können Reports für die Testdokumentation generieren. 

\section{Metasploit Framework}\label{subsec:metasploit}

Im Jahr 2003 begann der amerikanische Sicherheitsexperte H. D. Moore mit der Entwicklung des Metasploit-Projekts\footnote{\url{https://www.metasploit.com/}}. Die Grundidee hinter der Anwendung war damals, wie heute, der Öffentlichkeit Zugang zu detaillierten Informationen über Sicherheitslücken zu verschaffen, was nach wie vor die Frage nach dem richtigen Vorgehen bei der Veröffentlichung von Sicherheitslücken aufwirft \cite[S.45]{Messner2017}.

Seit der Version 3 des Projekts ist die Anwendung in Ruby verfasst und vereint als Framework eine Vielzahl an Tools. Das reine Open Source Framework kann über die Kommandozeilenanwendung \texttt{msfconsole} oder über die von \texttt{msfrpc} bereitgestellte API bedient werden. Die Pro-Version der Anwendung ermöglicht es zusätzlich, die Anwendung über ein Webinterface zu bedienen.

\subsection{Module}\label{subsec:metasploitmodule}
Unter Modulen versteht man im Kontext von Metasploit ein Stück Software, das parametrisiert werden kann und bei der Ausführung eine bestimmte Aufgabe ausführt. Eingeteilt werden die Module in die folgenden Kategorien:

\begin{itemize}
  \item \textbf{Auxiliary} Führt beliebige Aktionen durch, die nicht mit der Ausnutzung einer Schwachstelle in Verbindung stehen
  \item \textbf{Exploits} Nutzt eine Sicherheitslücke in einem System oder einer Anwendung aus
  \item \textbf{Payloads} Code, der ausgeführt wird, nachdem ein Exploit ein System erfolgreich kompromittiert hat
   \item \textbf{NOPs} Code, der nichts tut, um den Speicher für Exploits entsprechend vorzubereiten
  \item \textbf{Encoders} Kodieren eine Payload oder Nop so, dass sie von Schutzmaßnahmen nicht erkannt werden
\end{itemize}
\cite[]{metasploitglosar}

\subsection{Jobs}\label{subsubsec:auxiliarys}

Aufgaben, wie das Ausführen eines Moduls, können in Metasploit mithilfe eines Jobs durchgeführt werden. Dafür wird vor dem Start des Jobs dieser entsprechend konfiguriert, sodass er z. B. Konsolenausgaben in einer Datei ablegt. Jeder Job erhält beim Erstellen eine eindeutige ID, über die er gestartet oder gestoppt werden kann. 

\section{Scapy}\label{subsec:scapy}
Bei Scapy handelt es sich um eine Python Bibliothek, welche eine Vielzahl an Funktionalitäten für die Manipulation von Netzwerkpaketen liefert. Dafür wird in Python definiert, wie ein Paket aufgebaut ist, was das Parsen und das Bearbeiten vereinfacht. Zusätzlich werden beim Bearbeiten von Paketen Abhängigkeiten wie z. B. Checksummen selbstständig neu berechnet \cite{scappy}.

In den Arbeiten von \cite{scapyAutomotive} wird Scapy um Paketdefinitionen\footnote{\url{https://scapy.readthedocs.io/en/latest/layers/automotive.html}} bekannter Automobilprotokolle ergänzt, was eine tiefe Untersuchung dieser erlaubt.